**DxMsgConv** is an element that processes inference metadata from upstream **DxPostprocess** elements and converts it into message payloads in various formats.  
The converted payloads are then passed to the DxMsgBroker element, which transmits them to a broker server.  

A user-defined custom library is required to implement the actual message format logic. Refer to the **Chapter 4. Writing Your Own Application `"Custom Message Convert Library Documentation"`**. user-defined custom library is required to implement the actual message format logic. Refer to the **Chapter 4. Writing Your Own Application `"Custom Message Convert Library Documentation"`**.MsgConv** is an element that processes inference metadata from upstream **DxPostprocess** elements and converts it into message payloads in various formats.  
The converted payloads are then passed to the DxMsgBroker element, which transmits them to a broker server.  

A user-defined custom library is required to implement the actual message format logic. Refer to the **Chapter 4. Writing Your Own Application `“Custom Pre-Process Library Documentation”`**.  

### **Key Features**

**Metadata Conversion**  

- Converts metadata generated by **DxPostprocess** into structured message formats through custom library implementation.  
- The actual message format and structure are defined by the user-implemented custom library.
- Requires a custom shared library to define and implement the required message formats.  

**Integration with DxMsgBroker**  

- Passes formatted message payloads (as generated by the custom library) downstream to **DxMsgBroker**, which handles delivery to external systems.  

**Configuration**  

- Message format conversion can be customized using a configuration file.

### **Example Output Format**

The element processes metadata through the custom library to generate message payloads. The default example custom library provided with DX-STREAM generates JSON messages with comprehensive object detection information:

```json
{
  "streamId": 0,
  "seqId": 123,
  "width": 1920,
  "height": 1080,
  "objects": [
    {
      "object": {
        "label_id": 1,
        "track_id": 42,
        "confidence": 0.87,
        "name": "person",
        "box": { ... },
        "body_feature": [...],
        "segment": { ... },
        "pose": { ... },
        "face": { ... }
      }
    }
  ]
}
```

**Note:** The actual message format depends entirely on the implementation of your custom library. The above is just an example from the provided default library. For detailed implementation guidance and complete JSON structure examples, refer to **Chapter 4. Writing Your Own Application**.

### **Hierarchy**

```
GObject
 +----GInitiallyUnowned
       +----GstObject
             +----GstElement
                   +----GstBaseTransform
                         +----GstDxMsgConv
```

### **Properties**

| **Name**            | **Description**                                                      | **Type**  | **Default Value** |
|----------------------|----------------------------------------------------------------------|-----------|--------------------|
| `config-file-path`  | Path to the configuration file. (optional).| String    | `null`     |
| `library-file-path` | Path to the custom message converter library. **Required**.       | String    | `null`           |
| `message-interval` | Frame interval at which message is converted.                      | Integer    | `1`             |

---

**Notes.**  

- The element itself does not define the message format - this is entirely determined by your custom library implementation.
- The default example library provided with DX-STREAM generates JSON format, but you can implement any message format in your custom library.  

---

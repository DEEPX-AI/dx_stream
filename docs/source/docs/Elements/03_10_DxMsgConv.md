**DxMsgConv** is an element that processes inference metadata from upstream **DxPostprocess** elements and converts it into message payloads in various formats.

This element bridges internal AI pipeline processing and external communication systems. It receives the raw inference metadata—data about detected objects, classifications, and tracking—from the upstream **DxPostprocess** elements.
**DxMsgConv** then transforms this complex metadata into structured message payloads using various standard formats, such as JSON or Protocol Buffers. Once converted, these payloads are passed downstream to the **DxMsgBroker** element, which is responsible for transmitting them reliably to an external broker server (like an MQTT or Kafka broker).

To properly implement the specific structure and content required for the final messages—referred to as the "actual message format logic"—a user-defined custom library is required. This library contains the unique code that dictates how the inference metadata is mapped into the desired message payload structure. For guidance on developing and integrating this custom logic, users must consult the relevant documentation, specifically: **Chapter. Writing Your Own Application "Custom Message Convert Library Documentation".**


### **Key Features**

**Metadata Conversion**  

- Converts metadata generated by **DxPostprocess** into structured message formats through custom library implementation.  
- The actual message format and structure are defined by the user-implemented custom library.
- Requires a custom shared library to define and implement the required message formats.  

**Integration with DxMsgBroker**  

- Passes formatted message payloads (as generated by the custom library) downstream to **DxMsgBroker**, which handles delivery to external systems.  

**Configuration**  

- Message format conversion can be customized using a configuration file.

### **Example Output Format**

The element processes metadata through the custom library to generate message payloads. The default example custom library provided with DX-STREAM generates JSON messages with comprehensive object detection information:

```json
{
  "streamId": 0,
  "seqId": 123,
  "width": 1920,
  "height": 1080,
  "objects": [
    {
      "object": {
        "label_id": 1,
        "track_id": 42,
        "confidence": 0.87,
        "name": "person",
        "box": { ... },
        "body_feature": [...],
        "segment": { ... },
        "pose": { ... },
        "face": { ... }
      }
    }
  ]
}
```

!!! note "NOTE" 

    The actual message format depends entirely on the implementation of your custom library. The above is just an example from the provided default library. For detailed implementation guidance and complete JSON structure examples, refer to **Chapter 4. Writing Your Own Application**.

### **Hierarchy**

```
GObject
 +----GInitiallyUnowned
       +----GstObject
             +----GstElement
                   +----GstBaseTransform
                         +----GstDxMsgConv
```

### **Properties**

| **Name**            | **Description**                                                      | **Type**  | **Default Value** |
|----------------------|----------------------------------------------------------------------|-----------|--------------------|
| `config-file-path`  | Path to the configuration file. (optional).| String    | `null`     |
| `library-file-path` | Path to the custom message converter library. **Required**.       | String    | `null`           |
| `message-interval` | Frame interval at which message is converted.                      | Integer    | `1`             |

---

!!! note "NOTE"  

    - The element itself does not define the message format - this is entirely determined by your custom library implementation.
    - The default example library provided with DX-STREAM generates JSON format, but you can implement any message format in your custom library.  

---
